name: Release

run-name: bump ${{ inputs.version }} version by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      version:
        type: choice
        description: 'part of the project version to update'
        options:
        - major
        - minor
        - patch
        required: true

env:
  PIP_DISABLE_PIP_VERSION_CHECK: on
  PIP_NO_CLEAN: on
  PIP_NO_INPUT: on
  PIP_PREFER_BINARY: on
  PY_COLORS: "1"
  IMAGE_NAME: ghcr.io/${{ github.repository }}

permissions:
  contents: write
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      tag: ${{ steps.release.outputs.tag }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v6
        with:
          fetch-depth: 1
          token: ${{ secrets.WORKFLOW_TOKEN }}

      - name: Configure git
        env:
          MEX_BOT_EMAIL: ${{ vars.MEX_BOT_EMAIL }}
          MEX_BOT_USER: ${{ vars.MEX_BOT_USER }}
          # SIGNING_KEY: ${{ secrets.SIGNING_KEY }}
          # SIGNING_PUB: ${{ secrets.SIGNING_PUB }}
        run: |
          git config user.name "${{ vars.MEX_BOT_USER }}"
          git config user.email "${{ vars.MEX_BOT_EMAIL }}"

      - name: Release new version
        id: release
        run: |
          current_version=$(grep -m1 'version = "' pyproject.toml | cut -d '"' -f 2)
          IFS='.' read -r major minor patch <<< "$current_version"

          if [ "${{ inputs.version }}" == "major" ]; then major=$((major+1)); minor=0; patch=0; fi
          if [ "${{ inputs.version }}" == "minor" ]; then minor=$((minor+1)); patch=0; fi
          if [ "${{ inputs.version }}" == "patch" ]; then patch=$((patch+1)); fi

          new_version="$major.$minor.$patch"
          echo "Bumping from $current_version to $new_version"

          sed -i "s/version = \"$current_version\"/version = \"$new_version\"/" pyproject.toml

          git add pyproject.toml
          git commit -m "bump version to $new_version"
          git tag "$new_version"
          git push origin main
          git push origin "$new_version"

          echo "tag=$new_version" >> "$GITHUB_OUTPUT"

  containerize:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: release
    steps:
      - name: Checkout repo
        uses: actions/checkout@v6
        with:
          fetch-depth: 1
          ref: ${{ needs.release.outputs.tag }}
          persist-credentials: false

      - name: Login to container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{github.actor}}
          password: ${{secrets.GITHUB_TOKEN}}

      - name: Build, tag and push docker image
        run: |
          docker build . \
          --tag $IMAGE_NAME:latest \
          --tag $IMAGE_NAME:${{ github.sha }} \
          --tag $IMAGE_NAME:${{ needs.release.outputs.tag }}
          docker push --all-tags $IMAGE_NAME

  # distribute:
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 10
  #   needs: release
  #   environment:
  #     name: pypi
  #     url: https://pypi.org/p/mex-artificial
  #   permissions:
  #     id-token: write  # IMPORTANT: mandatory for trusted publishing
  #   steps:
  #     - name: Checkout repo
  #       uses: actions/checkout@v6
  #       with:
  #         fetch-depth: 1
  #         ref: ${{ needs.release.outputs.tag }}
  #         persist-credentials: false

  #     - name: Cache requirements
  #       uses: actions/cache@v4
  #       env:
  #         cache-name: cache-requirements
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ env.cache-name }}-${{ hashFiles('requirements.txt') }}
  #         restore-keys: |
  #           ${{ env.cache-name }}-

  #     - name: Setup python
  #       uses: actions/setup-python@v6
  #       with:
  #         python-version: 3.11

  #     - name: Install requirements
  #       run: make setup

  #     - name: Build wheel and sdist distros and create a github release
  #       env:
  #         GH_TOKEN: ${{ secrets.WORKFLOW_TOKEN }}
  #       run: |
  #         gh release create ${{ needs.release.outputs.tag }} --generate-notes --latest --verify-tag
  #         pdm build --dest dist
  #         for filename in dist/*; do
  #           gh release upload ${{ needs.release.outputs.tag }} ${filename};
  #         done

  #     - name: Publish distribution ðŸ“¦ to PyPI
  #       uses: pypa/gh-action-pypi-publish@release/v1
